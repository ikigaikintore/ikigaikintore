// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: endpoints.v1.proto
/* eslint-disable */

import type { ByteSource, PartialDeep } from "protoscript";
import * as protoscript from "protoscript";
import { JSONrequest, PBrequest } from "twirpscript";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running `npx twirpscript`.
export { MIN_SUPPORTED_VERSION_0_0_56 } from "twirpscript";
import type { ClientConfiguration } from "twirpscript";

//========================================//
//                 Types                  //
//========================================//

export type WeatherType =
  | "UNKNOWN"
  | "THUNDERSTORM"
  | "DRIZZLE"
  | "RAIN"
  | "SNOW"
  | "MIST"
  | "SMOKE"
  | "HAZE"
  | "DUST"
  | "FOG"
  | "SAND"
  | "ASH"
  | "SQUALL"
  | "TORNADO"
  | "CLEAR"
  | "CLOUDS";

export interface WeatherFilter {
  locationCityName?: string | null | undefined;
  latitude: number;
  longitude: number;
}

export interface WeatherRequest {
  weatherFilter?: WeatherFilter | null | undefined;
}

export interface WeatherCurrent {
  temperature: number;
  windSpeed: number;
  timestamp: bigint;
  humidity: number;
  weather: WeatherType;
  icon: string;
}

export interface TemperatureRange {
  max: number;
  min: number;
}

export interface WeatherDailyPoint {
  timestamp: bigint;
  temperature: number;
  humidity: number;
  temperatureRange: TemperatureRange;
  weather: WeatherType;
  icon: string;
}

export interface WeatherReply {
  weatherPoint: WeatherDailyPoint[];
  weatherCurrent: WeatherCurrent;
}

export interface FilterSpam {
  sender: string;
  before?: protoscript.Timestamp | null | undefined;
  after?: protoscript.Timestamp | null | undefined;
}

export interface Spam {
  sender: string;
  content: string;
  date: protoscript.Timestamp;
  id: string;
}

export interface MailRequest {
  threadId: string;
  message: Spam;
}

//========================================//
//        Weather Protobuf Client         //
//========================================//

export async function GetWeather(
  weatherRequest: WeatherRequest,
  config?: ClientConfiguration,
): Promise<WeatherReply> {
  const response = await PBrequest(
    "/endpoints.v1.Weather/GetWeather",
    WeatherRequest.encode(weatherRequest),
    config,
  );
  return WeatherReply.decode(response);
}

//========================================//
//          Mail Protobuf Client          //
//========================================//

export async function ListSpam(
  filterSpam: FilterSpam,
  config?: ClientConfiguration,
): Promise<Spam> {
  const response = await PBrequest(
    "/endpoints.v1.Mail/ListSpam",
    FilterSpam.encode(filterSpam),
    config,
  );
  return Spam.decode(response);
}

export async function Reply(
  mailRequest: MailRequest,
  config?: ClientConfiguration,
): Promise<protoscript.Empty> {
  const response = await PBrequest(
    "/endpoints.v1.Mail/Reply",
    MailRequest.encode(mailRequest),
    config,
  );
  return protoscript.Empty.decode(response);
}

//========================================//
//          Weather JSON Client           //
//========================================//

export async function GetWeatherJSON(
  weatherRequest: WeatherRequest,
  config?: ClientConfiguration,
): Promise<WeatherReply> {
  const response = await JSONrequest(
    "/endpoints.v1.Weather/GetWeather",
    WeatherRequestJSON.encode(weatherRequest),
    config,
  );
  return WeatherReplyJSON.decode(response);
}

//========================================//
//            Mail JSON Client            //
//========================================//

export async function ListSpamJSON(
  filterSpam: FilterSpam,
  config?: ClientConfiguration,
): Promise<Spam> {
  const response = await JSONrequest(
    "/endpoints.v1.Mail/ListSpam",
    FilterSpamJSON.encode(filterSpam),
    config,
  );
  return SpamJSON.decode(response);
}

export async function ReplyJSON(
  mailRequest: MailRequest,
  config?: ClientConfiguration,
): Promise<protoscript.Empty> {
  const response = await JSONrequest(
    "/endpoints.v1.Mail/Reply",
    MailRequestJSON.encode(mailRequest),
    config,
  );
  return protoscript.EmptyJSON.decode(response);
}

//========================================//
//                Weather                 //
//========================================//

export interface Weather<Context = unknown> {
  GetWeather: (
    weatherRequest: WeatherRequest,
    context: Context,
  ) => Promise<WeatherReply> | WeatherReply;
}

export function createWeather<Context>(service: Weather<Context>) {
  return {
    name: "endpoints.v1.Weather",
    methods: {
      GetWeather: {
        name: "GetWeather",
        handler: service.GetWeather,
        input: { protobuf: WeatherRequest, json: WeatherRequestJSON },
        output: { protobuf: WeatherReply, json: WeatherReplyJSON },
      },
    },
  } as const;
}

//========================================//
//                  Mail                  //
//========================================//

export interface Mail<Context = unknown> {
  ListSpam: (filterSpam: FilterSpam, context: Context) => Promise<Spam> | Spam;
  Reply: (
    mailRequest: MailRequest,
    context: Context,
  ) => Promise<protoscript.Empty> | protoscript.Empty;
}

export function createMail<Context>(service: Mail<Context>) {
  return {
    name: "endpoints.v1.Mail",
    methods: {
      ListSpam: {
        name: "ListSpam",
        handler: service.ListSpam,
        input: { protobuf: FilterSpam, json: FilterSpamJSON },
        output: { protobuf: Spam, json: SpamJSON },
      },
      Reply: {
        name: "Reply",
        handler: service.Reply,
        input: { protobuf: MailRequest, json: MailRequestJSON },
        output: { protobuf: protoscript.Empty, json: protoscript.EmptyJSON },
      },
    },
  } as const;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const WeatherType = {
  UNKNOWN: "UNKNOWN",
  THUNDERSTORM: "THUNDERSTORM",
  DRIZZLE: "DRIZZLE",
  RAIN: "RAIN",
  SNOW: "SNOW",
  MIST: "MIST",
  SMOKE: "SMOKE",
  HAZE: "HAZE",
  DUST: "DUST",
  FOG: "FOG",
  SAND: "SAND",
  ASH: "ASH",
  SQUALL: "SQUALL",
  TORNADO: "TORNADO",
  CLEAR: "CLEAR",
  CLOUDS: "CLOUDS",
  /**
   * @private
   */
  _fromInt: function (i: number): WeatherType {
    switch (i) {
      case 0: {
        return "UNKNOWN";
      }
      case 1: {
        return "THUNDERSTORM";
      }
      case 2: {
        return "DRIZZLE";
      }
      case 3: {
        return "RAIN";
      }
      case 4: {
        return "SNOW";
      }
      case 5: {
        return "MIST";
      }
      case 6: {
        return "SMOKE";
      }
      case 7: {
        return "HAZE";
      }
      case 8: {
        return "DUST";
      }
      case 9: {
        return "FOG";
      }
      case 10: {
        return "SAND";
      }
      case 11: {
        return "ASH";
      }
      case 12: {
        return "SQUALL";
      }
      case 13: {
        return "TORNADO";
      }
      case 14: {
        return "CLEAR";
      }
      case 15: {
        return "CLOUDS";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as WeatherType;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: WeatherType): number {
    switch (i) {
      case "UNKNOWN": {
        return 0;
      }
      case "THUNDERSTORM": {
        return 1;
      }
      case "DRIZZLE": {
        return 2;
      }
      case "RAIN": {
        return 3;
      }
      case "SNOW": {
        return 4;
      }
      case "MIST": {
        return 5;
      }
      case "SMOKE": {
        return 6;
      }
      case "HAZE": {
        return 7;
      }
      case "DUST": {
        return 8;
      }
      case "FOG": {
        return 9;
      }
      case "SAND": {
        return 10;
      }
      case "ASH": {
        return 11;
      }
      case "SQUALL": {
        return 12;
      }
      case "TORNADO": {
        return 13;
      }
      case "CLEAR": {
        return 14;
      }
      case "CLOUDS": {
        return 15;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const WeatherFilter = {
  /**
   * Serializes WeatherFilter to protobuf.
   */
  encode: function (msg: PartialDeep<WeatherFilter>): Uint8Array {
    return WeatherFilter._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes WeatherFilter from protobuf.
   */
  decode: function (bytes: ByteSource): WeatherFilter {
    return WeatherFilter._readMessage(
      WeatherFilter.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes WeatherFilter with all fields set to their default value.
   */
  initialize: function (msg?: Partial<WeatherFilter>): WeatherFilter {
    return {
      locationCityName: undefined,
      latitude: 0,
      longitude: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<WeatherFilter>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.locationCityName != undefined) {
      writer.writeString(1, msg.locationCityName);
    }
    if (msg.latitude) {
      writer.writeDouble(2, msg.latitude);
    }
    if (msg.longitude) {
      writer.writeDouble(3, msg.longitude);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: WeatherFilter,
    reader: protoscript.BinaryReader,
  ): WeatherFilter {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.locationCityName = reader.readString();
          break;
        }
        case 2: {
          msg.latitude = reader.readDouble();
          break;
        }
        case 3: {
          msg.longitude = reader.readDouble();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const WeatherRequest = {
  /**
   * Serializes WeatherRequest to protobuf.
   */
  encode: function (msg: PartialDeep<WeatherRequest>): Uint8Array {
    return WeatherRequest._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes WeatherRequest from protobuf.
   */
  decode: function (bytes: ByteSource): WeatherRequest {
    return WeatherRequest._readMessage(
      WeatherRequest.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes WeatherRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<WeatherRequest>): WeatherRequest {
    return {
      weatherFilter: undefined,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<WeatherRequest>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.weatherFilter != undefined) {
      writer.writeMessage(1, msg.weatherFilter, WeatherFilter._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: WeatherRequest,
    reader: protoscript.BinaryReader,
  ): WeatherRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.weatherFilter = WeatherFilter.initialize();
          reader.readMessage(msg.weatherFilter, WeatherFilter._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const WeatherCurrent = {
  /**
   * Serializes WeatherCurrent to protobuf.
   */
  encode: function (msg: PartialDeep<WeatherCurrent>): Uint8Array {
    return WeatherCurrent._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes WeatherCurrent from protobuf.
   */
  decode: function (bytes: ByteSource): WeatherCurrent {
    return WeatherCurrent._readMessage(
      WeatherCurrent.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes WeatherCurrent with all fields set to their default value.
   */
  initialize: function (msg?: Partial<WeatherCurrent>): WeatherCurrent {
    return {
      temperature: 0,
      windSpeed: 0,
      timestamp: 0n,
      humidity: 0,
      weather: WeatherType._fromInt(0),
      icon: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<WeatherCurrent>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.temperature) {
      writer.writeDouble(1, msg.temperature);
    }
    if (msg.windSpeed) {
      writer.writeDouble(2, msg.windSpeed);
    }
    if (msg.timestamp) {
      writer.writeUint64String(3, msg.timestamp.toString() as any);
    }
    if (msg.humidity) {
      writer.writeInt32(4, msg.humidity);
    }
    if (msg.weather && WeatherType._toInt(msg.weather)) {
      writer.writeEnum(5, WeatherType._toInt(msg.weather));
    }
    if (msg.icon) {
      writer.writeString(6, msg.icon);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: WeatherCurrent,
    reader: protoscript.BinaryReader,
  ): WeatherCurrent {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.temperature = reader.readDouble();
          break;
        }
        case 2: {
          msg.windSpeed = reader.readDouble();
          break;
        }
        case 3: {
          msg.timestamp = BigInt(reader.readUint64String());
          break;
        }
        case 4: {
          msg.humidity = reader.readInt32();
          break;
        }
        case 5: {
          msg.weather = WeatherType._fromInt(reader.readEnum());
          break;
        }
        case 6: {
          msg.icon = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TemperatureRange = {
  /**
   * Serializes TemperatureRange to protobuf.
   */
  encode: function (msg: PartialDeep<TemperatureRange>): Uint8Array {
    return TemperatureRange._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TemperatureRange from protobuf.
   */
  decode: function (bytes: ByteSource): TemperatureRange {
    return TemperatureRange._readMessage(
      TemperatureRange.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes TemperatureRange with all fields set to their default value.
   */
  initialize: function (msg?: Partial<TemperatureRange>): TemperatureRange {
    return {
      max: 0,
      min: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TemperatureRange>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.max) {
      writer.writeDouble(1, msg.max);
    }
    if (msg.min) {
      writer.writeDouble(2, msg.min);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TemperatureRange,
    reader: protoscript.BinaryReader,
  ): TemperatureRange {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.max = reader.readDouble();
          break;
        }
        case 2: {
          msg.min = reader.readDouble();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const WeatherDailyPoint = {
  /**
   * Serializes WeatherDailyPoint to protobuf.
   */
  encode: function (msg: PartialDeep<WeatherDailyPoint>): Uint8Array {
    return WeatherDailyPoint._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes WeatherDailyPoint from protobuf.
   */
  decode: function (bytes: ByteSource): WeatherDailyPoint {
    return WeatherDailyPoint._readMessage(
      WeatherDailyPoint.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes WeatherDailyPoint with all fields set to their default value.
   */
  initialize: function (msg?: Partial<WeatherDailyPoint>): WeatherDailyPoint {
    return {
      timestamp: 0n,
      temperature: 0,
      humidity: 0,
      temperatureRange: TemperatureRange.initialize(),
      weather: WeatherType._fromInt(0),
      icon: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<WeatherDailyPoint>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.timestamp) {
      writer.writeUint64String(1, msg.timestamp.toString() as any);
    }
    if (msg.temperature) {
      writer.writeDouble(2, msg.temperature);
    }
    if (msg.humidity) {
      writer.writeInt32(3, msg.humidity);
    }
    if (msg.temperatureRange) {
      writer.writeMessage(
        4,
        msg.temperatureRange,
        TemperatureRange._writeMessage,
      );
    }
    if (msg.weather && WeatherType._toInt(msg.weather)) {
      writer.writeEnum(5, WeatherType._toInt(msg.weather));
    }
    if (msg.icon) {
      writer.writeString(6, msg.icon);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: WeatherDailyPoint,
    reader: protoscript.BinaryReader,
  ): WeatherDailyPoint {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.timestamp = BigInt(reader.readUint64String());
          break;
        }
        case 2: {
          msg.temperature = reader.readDouble();
          break;
        }
        case 3: {
          msg.humidity = reader.readInt32();
          break;
        }
        case 4: {
          reader.readMessage(
            msg.temperatureRange,
            TemperatureRange._readMessage,
          );
          break;
        }
        case 5: {
          msg.weather = WeatherType._fromInt(reader.readEnum());
          break;
        }
        case 6: {
          msg.icon = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const WeatherReply = {
  /**
   * Serializes WeatherReply to protobuf.
   */
  encode: function (msg: PartialDeep<WeatherReply>): Uint8Array {
    return WeatherReply._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes WeatherReply from protobuf.
   */
  decode: function (bytes: ByteSource): WeatherReply {
    return WeatherReply._readMessage(
      WeatherReply.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes WeatherReply with all fields set to their default value.
   */
  initialize: function (msg?: Partial<WeatherReply>): WeatherReply {
    return {
      weatherPoint: [],
      weatherCurrent: WeatherCurrent.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<WeatherReply>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.weatherPoint?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.weatherPoint as any,
        WeatherDailyPoint._writeMessage,
      );
    }
    if (msg.weatherCurrent) {
      writer.writeMessage(2, msg.weatherCurrent, WeatherCurrent._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: WeatherReply,
    reader: protoscript.BinaryReader,
  ): WeatherReply {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = WeatherDailyPoint.initialize();
          reader.readMessage(m, WeatherDailyPoint._readMessage);
          msg.weatherPoint.push(m);
          break;
        }
        case 2: {
          reader.readMessage(msg.weatherCurrent, WeatherCurrent._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const FilterSpam = {
  /**
   * Serializes FilterSpam to protobuf.
   */
  encode: function (msg: PartialDeep<FilterSpam>): Uint8Array {
    return FilterSpam._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes FilterSpam from protobuf.
   */
  decode: function (bytes: ByteSource): FilterSpam {
    return FilterSpam._readMessage(
      FilterSpam.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes FilterSpam with all fields set to their default value.
   */
  initialize: function (msg?: Partial<FilterSpam>): FilterSpam {
    return {
      sender: "",
      before: undefined,
      after: undefined,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<FilterSpam>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.sender) {
      writer.writeString(1, msg.sender);
    }
    if (msg.before != undefined) {
      writer.writeMessage(2, msg.before, protoscript.Timestamp._writeMessage);
    }
    if (msg.after != undefined) {
      writer.writeMessage(3, msg.after, protoscript.Timestamp._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: FilterSpam,
    reader: protoscript.BinaryReader,
  ): FilterSpam {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.sender = reader.readString();
          break;
        }
        case 2: {
          msg.before = protoscript.Timestamp.initialize();
          reader.readMessage(msg.before, protoscript.Timestamp._readMessage);
          break;
        }
        case 3: {
          msg.after = protoscript.Timestamp.initialize();
          reader.readMessage(msg.after, protoscript.Timestamp._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Spam = {
  /**
   * Serializes Spam to protobuf.
   */
  encode: function (msg: PartialDeep<Spam>): Uint8Array {
    return Spam._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Spam from protobuf.
   */
  decode: function (bytes: ByteSource): Spam {
    return Spam._readMessage(
      Spam.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Spam with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Spam>): Spam {
    return {
      sender: "",
      content: "",
      date: protoscript.Timestamp.initialize(),
      id: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Spam>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.sender) {
      writer.writeString(1, msg.sender);
    }
    if (msg.content) {
      writer.writeString(2, msg.content);
    }
    if (msg.date) {
      writer.writeMessage(3, msg.date, protoscript.Timestamp._writeMessage);
    }
    if (msg.id) {
      writer.writeString(4, msg.id);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Spam, reader: protoscript.BinaryReader): Spam {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.sender = reader.readString();
          break;
        }
        case 2: {
          msg.content = reader.readString();
          break;
        }
        case 3: {
          reader.readMessage(msg.date, protoscript.Timestamp._readMessage);
          break;
        }
        case 4: {
          msg.id = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const MailRequest = {
  /**
   * Serializes MailRequest to protobuf.
   */
  encode: function (msg: PartialDeep<MailRequest>): Uint8Array {
    return MailRequest._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes MailRequest from protobuf.
   */
  decode: function (bytes: ByteSource): MailRequest {
    return MailRequest._readMessage(
      MailRequest.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes MailRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<MailRequest>): MailRequest {
    return {
      threadId: "",
      message: Spam.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<MailRequest>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.threadId) {
      writer.writeString(1, msg.threadId);
    }
    if (msg.message) {
      writer.writeMessage(2, msg.message, Spam._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: MailRequest,
    reader: protoscript.BinaryReader,
  ): MailRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.threadId = reader.readString();
          break;
        }
        case 2: {
          reader.readMessage(msg.message, Spam._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const WeatherTypeJSON = {
  UNKNOWN: "UNKNOWN",
  THUNDERSTORM: "THUNDERSTORM",
  DRIZZLE: "DRIZZLE",
  RAIN: "RAIN",
  SNOW: "SNOW",
  MIST: "MIST",
  SMOKE: "SMOKE",
  HAZE: "HAZE",
  DUST: "DUST",
  FOG: "FOG",
  SAND: "SAND",
  ASH: "ASH",
  SQUALL: "SQUALL",
  TORNADO: "TORNADO",
  CLEAR: "CLEAR",
  CLOUDS: "CLOUDS",
  /**
   * @private
   */
  _fromInt: function (i: number): WeatherType {
    switch (i) {
      case 0: {
        return "UNKNOWN";
      }
      case 1: {
        return "THUNDERSTORM";
      }
      case 2: {
        return "DRIZZLE";
      }
      case 3: {
        return "RAIN";
      }
      case 4: {
        return "SNOW";
      }
      case 5: {
        return "MIST";
      }
      case 6: {
        return "SMOKE";
      }
      case 7: {
        return "HAZE";
      }
      case 8: {
        return "DUST";
      }
      case 9: {
        return "FOG";
      }
      case 10: {
        return "SAND";
      }
      case 11: {
        return "ASH";
      }
      case 12: {
        return "SQUALL";
      }
      case 13: {
        return "TORNADO";
      }
      case 14: {
        return "CLEAR";
      }
      case 15: {
        return "CLOUDS";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as WeatherType;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: WeatherType): number {
    switch (i) {
      case "UNKNOWN": {
        return 0;
      }
      case "THUNDERSTORM": {
        return 1;
      }
      case "DRIZZLE": {
        return 2;
      }
      case "RAIN": {
        return 3;
      }
      case "SNOW": {
        return 4;
      }
      case "MIST": {
        return 5;
      }
      case "SMOKE": {
        return 6;
      }
      case "HAZE": {
        return 7;
      }
      case "DUST": {
        return 8;
      }
      case "FOG": {
        return 9;
      }
      case "SAND": {
        return 10;
      }
      case "ASH": {
        return 11;
      }
      case "SQUALL": {
        return 12;
      }
      case "TORNADO": {
        return 13;
      }
      case "CLEAR": {
        return 14;
      }
      case "CLOUDS": {
        return 15;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const WeatherFilterJSON = {
  /**
   * Serializes WeatherFilter to JSON.
   */
  encode: function (msg: PartialDeep<WeatherFilter>): string {
    return JSON.stringify(WeatherFilterJSON._writeMessage(msg));
  },

  /**
   * Deserializes WeatherFilter from JSON.
   */
  decode: function (json: string): WeatherFilter {
    return WeatherFilterJSON._readMessage(
      WeatherFilterJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes WeatherFilter with all fields set to their default value.
   */
  initialize: function (msg?: Partial<WeatherFilter>): WeatherFilter {
    return {
      locationCityName: undefined,
      latitude: 0,
      longitude: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<WeatherFilter>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.locationCityName != undefined) {
      json["locationCityName"] = msg.locationCityName;
    }
    if (msg.latitude) {
      json["latitude"] = msg.latitude;
    }
    if (msg.longitude) {
      json["longitude"] = msg.longitude;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: WeatherFilter, json: any): WeatherFilter {
    const _locationCityName_ = json["locationCityName"];
    if (_locationCityName_) {
      msg.locationCityName = _locationCityName_;
    }
    const _latitude_ = json["latitude"];
    if (_latitude_) {
      msg.latitude = protoscript.parseDouble(_latitude_);
    }
    const _longitude_ = json["longitude"];
    if (_longitude_) {
      msg.longitude = protoscript.parseDouble(_longitude_);
    }
    return msg;
  },
};

export const WeatherRequestJSON = {
  /**
   * Serializes WeatherRequest to JSON.
   */
  encode: function (msg: PartialDeep<WeatherRequest>): string {
    return JSON.stringify(WeatherRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes WeatherRequest from JSON.
   */
  decode: function (json: string): WeatherRequest {
    return WeatherRequestJSON._readMessage(
      WeatherRequestJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes WeatherRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<WeatherRequest>): WeatherRequest {
    return {
      weatherFilter: undefined,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<WeatherRequest>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.weatherFilter != undefined) {
      const _weatherFilter_ = WeatherFilterJSON._writeMessage(
        msg.weatherFilter,
      );
      json["weatherFilter"] = _weatherFilter_;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: WeatherRequest, json: any): WeatherRequest {
    const _weatherFilter_ = json["weatherFilter"];
    if (_weatherFilter_) {
      msg.weatherFilter = WeatherFilterJSON.initialize();
      WeatherFilterJSON._readMessage(msg.weatherFilter, _weatherFilter_);
    }
    return msg;
  },
};

export const WeatherCurrentJSON = {
  /**
   * Serializes WeatherCurrent to JSON.
   */
  encode: function (msg: PartialDeep<WeatherCurrent>): string {
    return JSON.stringify(WeatherCurrentJSON._writeMessage(msg));
  },

  /**
   * Deserializes WeatherCurrent from JSON.
   */
  decode: function (json: string): WeatherCurrent {
    return WeatherCurrentJSON._readMessage(
      WeatherCurrentJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes WeatherCurrent with all fields set to their default value.
   */
  initialize: function (msg?: Partial<WeatherCurrent>): WeatherCurrent {
    return {
      temperature: 0,
      windSpeed: 0,
      timestamp: 0n,
      humidity: 0,
      weather: WeatherType._fromInt(0),
      icon: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<WeatherCurrent>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.temperature) {
      json["temperature"] = msg.temperature;
    }
    if (msg.windSpeed) {
      json["windSpeed"] = msg.windSpeed;
    }
    if (msg.timestamp) {
      json["timestamp"] = String(msg.timestamp);
    }
    if (msg.humidity) {
      json["humidity"] = msg.humidity;
    }
    if (msg.weather && WeatherTypeJSON._toInt(msg.weather)) {
      json["weather"] = msg.weather;
    }
    if (msg.icon) {
      json["icon"] = msg.icon;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: WeatherCurrent, json: any): WeatherCurrent {
    const _temperature_ = json["temperature"];
    if (_temperature_) {
      msg.temperature = protoscript.parseDouble(_temperature_);
    }
    const _windSpeed_ = json["windSpeed"];
    if (_windSpeed_) {
      msg.windSpeed = protoscript.parseDouble(_windSpeed_);
    }
    const _timestamp_ = json["timestamp"];
    if (_timestamp_) {
      msg.timestamp = BigInt(_timestamp_);
    }
    const _humidity_ = json["humidity"];
    if (_humidity_) {
      msg.humidity = protoscript.parseNumber(_humidity_);
    }
    const _weather_ = json["weather"];
    if (_weather_) {
      msg.weather = WeatherType._fromInt(_weather_);
    }
    const _icon_ = json["icon"];
    if (_icon_) {
      msg.icon = _icon_;
    }
    return msg;
  },
};

export const TemperatureRangeJSON = {
  /**
   * Serializes TemperatureRange to JSON.
   */
  encode: function (msg: PartialDeep<TemperatureRange>): string {
    return JSON.stringify(TemperatureRangeJSON._writeMessage(msg));
  },

  /**
   * Deserializes TemperatureRange from JSON.
   */
  decode: function (json: string): TemperatureRange {
    return TemperatureRangeJSON._readMessage(
      TemperatureRangeJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TemperatureRange with all fields set to their default value.
   */
  initialize: function (msg?: Partial<TemperatureRange>): TemperatureRange {
    return {
      max: 0,
      min: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TemperatureRange>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.max) {
      json["max"] = msg.max;
    }
    if (msg.min) {
      json["min"] = msg.min;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TemperatureRange, json: any): TemperatureRange {
    const _max_ = json["max"];
    if (_max_) {
      msg.max = protoscript.parseDouble(_max_);
    }
    const _min_ = json["min"];
    if (_min_) {
      msg.min = protoscript.parseDouble(_min_);
    }
    return msg;
  },
};

export const WeatherDailyPointJSON = {
  /**
   * Serializes WeatherDailyPoint to JSON.
   */
  encode: function (msg: PartialDeep<WeatherDailyPoint>): string {
    return JSON.stringify(WeatherDailyPointJSON._writeMessage(msg));
  },

  /**
   * Deserializes WeatherDailyPoint from JSON.
   */
  decode: function (json: string): WeatherDailyPoint {
    return WeatherDailyPointJSON._readMessage(
      WeatherDailyPointJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes WeatherDailyPoint with all fields set to their default value.
   */
  initialize: function (msg?: Partial<WeatherDailyPoint>): WeatherDailyPoint {
    return {
      timestamp: 0n,
      temperature: 0,
      humidity: 0,
      temperatureRange: TemperatureRangeJSON.initialize(),
      weather: WeatherType._fromInt(0),
      icon: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<WeatherDailyPoint>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.timestamp) {
      json["timestamp"] = String(msg.timestamp);
    }
    if (msg.temperature) {
      json["temperature"] = msg.temperature;
    }
    if (msg.humidity) {
      json["humidity"] = msg.humidity;
    }
    if (msg.temperatureRange) {
      const _temperatureRange_ = TemperatureRangeJSON._writeMessage(
        msg.temperatureRange,
      );
      if (Object.keys(_temperatureRange_).length > 0) {
        json["temperatureRange"] = _temperatureRange_;
      }
    }
    if (msg.weather && WeatherTypeJSON._toInt(msg.weather)) {
      json["weather"] = msg.weather;
    }
    if (msg.icon) {
      json["icon"] = msg.icon;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: WeatherDailyPoint,
    json: any,
  ): WeatherDailyPoint {
    const _timestamp_ = json["timestamp"];
    if (_timestamp_) {
      msg.timestamp = BigInt(_timestamp_);
    }
    const _temperature_ = json["temperature"];
    if (_temperature_) {
      msg.temperature = protoscript.parseDouble(_temperature_);
    }
    const _humidity_ = json["humidity"];
    if (_humidity_) {
      msg.humidity = protoscript.parseNumber(_humidity_);
    }
    const _temperatureRange_ = json["temperatureRange"];
    if (_temperatureRange_) {
      TemperatureRangeJSON._readMessage(
        msg.temperatureRange,
        _temperatureRange_,
      );
    }
    const _weather_ = json["weather"];
    if (_weather_) {
      msg.weather = WeatherType._fromInt(_weather_);
    }
    const _icon_ = json["icon"];
    if (_icon_) {
      msg.icon = _icon_;
    }
    return msg;
  },
};

export const WeatherReplyJSON = {
  /**
   * Serializes WeatherReply to JSON.
   */
  encode: function (msg: PartialDeep<WeatherReply>): string {
    return JSON.stringify(WeatherReplyJSON._writeMessage(msg));
  },

  /**
   * Deserializes WeatherReply from JSON.
   */
  decode: function (json: string): WeatherReply {
    return WeatherReplyJSON._readMessage(
      WeatherReplyJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes WeatherReply with all fields set to their default value.
   */
  initialize: function (msg?: Partial<WeatherReply>): WeatherReply {
    return {
      weatherPoint: [],
      weatherCurrent: WeatherCurrentJSON.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<WeatherReply>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.weatherPoint?.length) {
      json["weatherPoint"] = msg.weatherPoint.map(
        WeatherDailyPointJSON._writeMessage,
      );
    }
    if (msg.weatherCurrent) {
      const _weatherCurrent_ = WeatherCurrentJSON._writeMessage(
        msg.weatherCurrent,
      );
      if (Object.keys(_weatherCurrent_).length > 0) {
        json["weatherCurrent"] = _weatherCurrent_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: WeatherReply, json: any): WeatherReply {
    const _weatherPoint_ = json["weatherPoint"];
    if (_weatherPoint_) {
      for (const item of _weatherPoint_) {
        const m = WeatherDailyPointJSON.initialize();
        WeatherDailyPointJSON._readMessage(m, item);
        msg.weatherPoint.push(m);
      }
    }
    const _weatherCurrent_ = json["weatherCurrent"];
    if (_weatherCurrent_) {
      WeatherCurrentJSON._readMessage(msg.weatherCurrent, _weatherCurrent_);
    }
    return msg;
  },
};

export const FilterSpamJSON = {
  /**
   * Serializes FilterSpam to JSON.
   */
  encode: function (msg: PartialDeep<FilterSpam>): string {
    return JSON.stringify(FilterSpamJSON._writeMessage(msg));
  },

  /**
   * Deserializes FilterSpam from JSON.
   */
  decode: function (json: string): FilterSpam {
    return FilterSpamJSON._readMessage(
      FilterSpamJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes FilterSpam with all fields set to their default value.
   */
  initialize: function (msg?: Partial<FilterSpam>): FilterSpam {
    return {
      sender: "",
      before: undefined,
      after: undefined,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<FilterSpam>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.sender) {
      json["sender"] = msg.sender;
    }
    if (msg.before != undefined) {
      json["before"] = protoscript.serializeTimestamp(msg.before);
    }
    if (msg.after != undefined) {
      json["after"] = protoscript.serializeTimestamp(msg.after);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: FilterSpam, json: any): FilterSpam {
    const _sender_ = json["sender"];
    if (_sender_) {
      msg.sender = _sender_;
    }
    const _before_ = json["before"];
    if (_before_) {
      msg.before = protoscript.parseTimestamp(_before_);
    }
    const _after_ = json["after"];
    if (_after_) {
      msg.after = protoscript.parseTimestamp(_after_);
    }
    return msg;
  },
};

export const SpamJSON = {
  /**
   * Serializes Spam to JSON.
   */
  encode: function (msg: PartialDeep<Spam>): string {
    return JSON.stringify(SpamJSON._writeMessage(msg));
  },

  /**
   * Deserializes Spam from JSON.
   */
  decode: function (json: string): Spam {
    return SpamJSON._readMessage(SpamJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Spam with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Spam>): Spam {
    return {
      sender: "",
      content: "",
      date: protoscript.TimestampJSON.initialize(),
      id: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: PartialDeep<Spam>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.sender) {
      json["sender"] = msg.sender;
    }
    if (msg.content) {
      json["content"] = msg.content;
    }
    if (msg.date && msg.date.seconds && msg.date.nanos) {
      json["date"] = protoscript.serializeTimestamp(msg.date);
    }
    if (msg.id) {
      json["id"] = msg.id;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Spam, json: any): Spam {
    const _sender_ = json["sender"];
    if (_sender_) {
      msg.sender = _sender_;
    }
    const _content_ = json["content"];
    if (_content_) {
      msg.content = _content_;
    }
    const _date_ = json["date"];
    if (_date_) {
      msg.date = protoscript.parseTimestamp(_date_);
    }
    const _id_ = json["id"];
    if (_id_) {
      msg.id = _id_;
    }
    return msg;
  },
};

export const MailRequestJSON = {
  /**
   * Serializes MailRequest to JSON.
   */
  encode: function (msg: PartialDeep<MailRequest>): string {
    return JSON.stringify(MailRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes MailRequest from JSON.
   */
  decode: function (json: string): MailRequest {
    return MailRequestJSON._readMessage(
      MailRequestJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes MailRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<MailRequest>): MailRequest {
    return {
      threadId: "",
      message: SpamJSON.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<MailRequest>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.threadId) {
      json["threadId"] = msg.threadId;
    }
    if (msg.message) {
      const _message_ = SpamJSON._writeMessage(msg.message);
      if (Object.keys(_message_).length > 0) {
        json["message"] = _message_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: MailRequest, json: any): MailRequest {
    const _threadId_ = json["threadId"];
    if (_threadId_) {
      msg.threadId = _threadId_;
    }
    const _message_ = json["message"];
    if (_message_) {
      SpamJSON._readMessage(msg.message, _message_);
    }
    return msg;
  },
};
