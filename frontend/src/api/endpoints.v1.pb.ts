// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: endpoints.v1.proto
/* eslint-disable */

import type { ByteSource, PartialDeep } from "protoscript";
import * as protoscript from "protoscript";
import { JSONrequest, PBrequest } from "twirpscript";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running `npx twirpscript`.
export { MIN_SUPPORTED_VERSION_0_0_56 } from "twirpscript";
import type { ClientConfiguration } from "twirpscript";

//========================================//
//                 Types                  //
//========================================//

export type WeatherType =
  | "UNKNOWN"
  | "THUNDERSTORM"
  | "DRIZZLE"
  | "RAIN"
  | "SNOW"
  | "MIST"
  | "SMOKE"
  | "HAZE"
  | "DUST"
  | "FOG"
  | "SAND"
  | "ASH"
  | "SQUALL"
  | "TORNADO"
  | "CLEAR"
  | "CLOUDS";

export interface WeatherFilter {
  location: string;
}

export interface WeatherRequest {
  weatherFilter?: WeatherFilter | null | undefined;
}

export interface WeatherCurrent {
  temperature: number;
  windSpeed: number;
  timestamp: bigint;
  humidity: number;
  weather: WeatherType;
}

export interface TemperatureRange {
  max: number;
  min: number;
}

export interface WeatherDailyPoint {
  timestamp: bigint;
  temperature: number;
  humidity: number;
  temperatureRange: TemperatureRange;
  weather: WeatherType;
}

export interface WeatherReply {
  weatherPoint: WeatherDailyPoint[];
  weatherCurrent: WeatherCurrent;
}

//========================================//
//        Weather Protobuf Client         //
//========================================//

export async function GetWeather(
  weatherRequest: WeatherRequest,
  config?: ClientConfiguration,
): Promise<WeatherReply> {
  const response = await PBrequest(
    "/endpoints.v1.Weather/GetWeather",
    WeatherRequest.encode(weatherRequest),
    config,
  );
  return WeatherReply.decode(response);
}

//========================================//
//          Weather JSON Client           //
//========================================//

export async function GetWeatherJSON(
  weatherRequest: WeatherRequest,
  config?: ClientConfiguration,
): Promise<WeatherReply> {
  const response = await JSONrequest(
    "/endpoints.v1.Weather/GetWeather",
    WeatherRequestJSON.encode(weatherRequest),
    config,
  );
  return WeatherReplyJSON.decode(response);
}

//========================================//
//                Weather                 //
//========================================//

export interface Weather<Context = unknown> {
  GetWeather: (
    weatherRequest: WeatherRequest,
    context: Context,
  ) => Promise<WeatherReply> | WeatherReply;
}

export function createWeather<Context>(service: Weather<Context>) {
  return {
    name: "endpoints.v1.Weather",
    methods: {
      GetWeather: {
        name: "GetWeather",
        handler: service.GetWeather,
        input: { protobuf: WeatherRequest, json: WeatherRequestJSON },
        output: { protobuf: WeatherReply, json: WeatherReplyJSON },
      },
    },
  } as const;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const WeatherType = {
  UNKNOWN: "UNKNOWN",
  THUNDERSTORM: "THUNDERSTORM",
  DRIZZLE: "DRIZZLE",
  RAIN: "RAIN",
  SNOW: "SNOW",
  MIST: "MIST",
  SMOKE: "SMOKE",
  HAZE: "HAZE",
  DUST: "DUST",
  FOG: "FOG",
  SAND: "SAND",
  ASH: "ASH",
  SQUALL: "SQUALL",
  TORNADO: "TORNADO",
  CLEAR: "CLEAR",
  CLOUDS: "CLOUDS",
  /**
   * @private
   */
  _fromInt: function (i: number): WeatherType {
    switch (i) {
      case 0: {
        return "UNKNOWN";
      }
      case 1: {
        return "THUNDERSTORM";
      }
      case 2: {
        return "DRIZZLE";
      }
      case 3: {
        return "RAIN";
      }
      case 4: {
        return "SNOW";
      }
      case 5: {
        return "MIST";
      }
      case 6: {
        return "SMOKE";
      }
      case 7: {
        return "HAZE";
      }
      case 8: {
        return "DUST";
      }
      case 9: {
        return "FOG";
      }
      case 10: {
        return "SAND";
      }
      case 11: {
        return "ASH";
      }
      case 12: {
        return "SQUALL";
      }
      case 13: {
        return "TORNADO";
      }
      case 14: {
        return "CLEAR";
      }
      case 15: {
        return "CLOUDS";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as WeatherType;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: WeatherType): number {
    switch (i) {
      case "UNKNOWN": {
        return 0;
      }
      case "THUNDERSTORM": {
        return 1;
      }
      case "DRIZZLE": {
        return 2;
      }
      case "RAIN": {
        return 3;
      }
      case "SNOW": {
        return 4;
      }
      case "MIST": {
        return 5;
      }
      case "SMOKE": {
        return 6;
      }
      case "HAZE": {
        return 7;
      }
      case "DUST": {
        return 8;
      }
      case "FOG": {
        return 9;
      }
      case "SAND": {
        return 10;
      }
      case "ASH": {
        return 11;
      }
      case "SQUALL": {
        return 12;
      }
      case "TORNADO": {
        return 13;
      }
      case "CLEAR": {
        return 14;
      }
      case "CLOUDS": {
        return 15;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const WeatherFilter = {
  /**
   * Serializes WeatherFilter to protobuf.
   */
  encode: function (msg: PartialDeep<WeatherFilter>): Uint8Array {
    return WeatherFilter._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes WeatherFilter from protobuf.
   */
  decode: function (bytes: ByteSource): WeatherFilter {
    return WeatherFilter._readMessage(
      WeatherFilter.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes WeatherFilter with all fields set to their default value.
   */
  initialize: function (msg?: Partial<WeatherFilter>): WeatherFilter {
    return {
      location: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<WeatherFilter>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.location) {
      writer.writeString(1, msg.location);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: WeatherFilter,
    reader: protoscript.BinaryReader,
  ): WeatherFilter {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.location = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const WeatherRequest = {
  /**
   * Serializes WeatherRequest to protobuf.
   */
  encode: function (msg: PartialDeep<WeatherRequest>): Uint8Array {
    return WeatherRequest._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes WeatherRequest from protobuf.
   */
  decode: function (bytes: ByteSource): WeatherRequest {
    return WeatherRequest._readMessage(
      WeatherRequest.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes WeatherRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<WeatherRequest>): WeatherRequest {
    return {
      weatherFilter: undefined,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<WeatherRequest>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.weatherFilter != undefined) {
      writer.writeMessage(1, msg.weatherFilter, WeatherFilter._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: WeatherRequest,
    reader: protoscript.BinaryReader,
  ): WeatherRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.weatherFilter = WeatherFilter.initialize();
          reader.readMessage(msg.weatherFilter, WeatherFilter._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const WeatherCurrent = {
  /**
   * Serializes WeatherCurrent to protobuf.
   */
  encode: function (msg: PartialDeep<WeatherCurrent>): Uint8Array {
    return WeatherCurrent._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes WeatherCurrent from protobuf.
   */
  decode: function (bytes: ByteSource): WeatherCurrent {
    return WeatherCurrent._readMessage(
      WeatherCurrent.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes WeatherCurrent with all fields set to their default value.
   */
  initialize: function (msg?: Partial<WeatherCurrent>): WeatherCurrent {
    return {
      temperature: 0,
      windSpeed: 0,
      timestamp: 0n,
      humidity: 0,
      weather: WeatherType._fromInt(0),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<WeatherCurrent>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.temperature) {
      writer.writeDouble(1, msg.temperature);
    }
    if (msg.windSpeed) {
      writer.writeDouble(2, msg.windSpeed);
    }
    if (msg.timestamp) {
      writer.writeUint64String(3, msg.timestamp.toString() as any);
    }
    if (msg.humidity) {
      writer.writeInt32(4, msg.humidity);
    }
    if (msg.weather && WeatherType._toInt(msg.weather)) {
      writer.writeEnum(5, WeatherType._toInt(msg.weather));
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: WeatherCurrent,
    reader: protoscript.BinaryReader,
  ): WeatherCurrent {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.temperature = reader.readDouble();
          break;
        }
        case 2: {
          msg.windSpeed = reader.readDouble();
          break;
        }
        case 3: {
          msg.timestamp = BigInt(reader.readUint64String());
          break;
        }
        case 4: {
          msg.humidity = reader.readInt32();
          break;
        }
        case 5: {
          msg.weather = WeatherType._fromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const TemperatureRange = {
  /**
   * Serializes TemperatureRange to protobuf.
   */
  encode: function (msg: PartialDeep<TemperatureRange>): Uint8Array {
    return TemperatureRange._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes TemperatureRange from protobuf.
   */
  decode: function (bytes: ByteSource): TemperatureRange {
    return TemperatureRange._readMessage(
      TemperatureRange.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes TemperatureRange with all fields set to their default value.
   */
  initialize: function (msg?: Partial<TemperatureRange>): TemperatureRange {
    return {
      max: 0,
      min: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TemperatureRange>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.max) {
      writer.writeDouble(1, msg.max);
    }
    if (msg.min) {
      writer.writeDouble(2, msg.min);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: TemperatureRange,
    reader: protoscript.BinaryReader,
  ): TemperatureRange {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.max = reader.readDouble();
          break;
        }
        case 2: {
          msg.min = reader.readDouble();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const WeatherDailyPoint = {
  /**
   * Serializes WeatherDailyPoint to protobuf.
   */
  encode: function (msg: PartialDeep<WeatherDailyPoint>): Uint8Array {
    return WeatherDailyPoint._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes WeatherDailyPoint from protobuf.
   */
  decode: function (bytes: ByteSource): WeatherDailyPoint {
    return WeatherDailyPoint._readMessage(
      WeatherDailyPoint.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes WeatherDailyPoint with all fields set to their default value.
   */
  initialize: function (msg?: Partial<WeatherDailyPoint>): WeatherDailyPoint {
    return {
      timestamp: 0n,
      temperature: 0,
      humidity: 0,
      temperatureRange: TemperatureRange.initialize(),
      weather: WeatherType._fromInt(0),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<WeatherDailyPoint>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.timestamp) {
      writer.writeUint64String(1, msg.timestamp.toString() as any);
    }
    if (msg.temperature) {
      writer.writeDouble(2, msg.temperature);
    }
    if (msg.humidity) {
      writer.writeInt32(3, msg.humidity);
    }
    if (msg.temperatureRange) {
      writer.writeMessage(
        4,
        msg.temperatureRange,
        TemperatureRange._writeMessage,
      );
    }
    if (msg.weather && WeatherType._toInt(msg.weather)) {
      writer.writeEnum(5, WeatherType._toInt(msg.weather));
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: WeatherDailyPoint,
    reader: protoscript.BinaryReader,
  ): WeatherDailyPoint {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.timestamp = BigInt(reader.readUint64String());
          break;
        }
        case 2: {
          msg.temperature = reader.readDouble();
          break;
        }
        case 3: {
          msg.humidity = reader.readInt32();
          break;
        }
        case 4: {
          reader.readMessage(
            msg.temperatureRange,
            TemperatureRange._readMessage,
          );
          break;
        }
        case 5: {
          msg.weather = WeatherType._fromInt(reader.readEnum());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const WeatherReply = {
  /**
   * Serializes WeatherReply to protobuf.
   */
  encode: function (msg: PartialDeep<WeatherReply>): Uint8Array {
    return WeatherReply._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes WeatherReply from protobuf.
   */
  decode: function (bytes: ByteSource): WeatherReply {
    return WeatherReply._readMessage(
      WeatherReply.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes WeatherReply with all fields set to their default value.
   */
  initialize: function (msg?: Partial<WeatherReply>): WeatherReply {
    return {
      weatherPoint: [],
      weatherCurrent: WeatherCurrent.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<WeatherReply>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.weatherPoint?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.weatherPoint as any,
        WeatherDailyPoint._writeMessage,
      );
    }
    if (msg.weatherCurrent) {
      writer.writeMessage(2, msg.weatherCurrent, WeatherCurrent._writeMessage);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: WeatherReply,
    reader: protoscript.BinaryReader,
  ): WeatherReply {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = WeatherDailyPoint.initialize();
          reader.readMessage(m, WeatherDailyPoint._readMessage);
          msg.weatherPoint.push(m);
          break;
        }
        case 2: {
          reader.readMessage(msg.weatherCurrent, WeatherCurrent._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const WeatherTypeJSON = {
  UNKNOWN: "UNKNOWN",
  THUNDERSTORM: "THUNDERSTORM",
  DRIZZLE: "DRIZZLE",
  RAIN: "RAIN",
  SNOW: "SNOW",
  MIST: "MIST",
  SMOKE: "SMOKE",
  HAZE: "HAZE",
  DUST: "DUST",
  FOG: "FOG",
  SAND: "SAND",
  ASH: "ASH",
  SQUALL: "SQUALL",
  TORNADO: "TORNADO",
  CLEAR: "CLEAR",
  CLOUDS: "CLOUDS",
  /**
   * @private
   */
  _fromInt: function (i: number): WeatherType {
    switch (i) {
      case 0: {
        return "UNKNOWN";
      }
      case 1: {
        return "THUNDERSTORM";
      }
      case 2: {
        return "DRIZZLE";
      }
      case 3: {
        return "RAIN";
      }
      case 4: {
        return "SNOW";
      }
      case 5: {
        return "MIST";
      }
      case 6: {
        return "SMOKE";
      }
      case 7: {
        return "HAZE";
      }
      case 8: {
        return "DUST";
      }
      case 9: {
        return "FOG";
      }
      case 10: {
        return "SAND";
      }
      case 11: {
        return "ASH";
      }
      case 12: {
        return "SQUALL";
      }
      case 13: {
        return "TORNADO";
      }
      case 14: {
        return "CLEAR";
      }
      case 15: {
        return "CLOUDS";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as WeatherType;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: WeatherType): number {
    switch (i) {
      case "UNKNOWN": {
        return 0;
      }
      case "THUNDERSTORM": {
        return 1;
      }
      case "DRIZZLE": {
        return 2;
      }
      case "RAIN": {
        return 3;
      }
      case "SNOW": {
        return 4;
      }
      case "MIST": {
        return 5;
      }
      case "SMOKE": {
        return 6;
      }
      case "HAZE": {
        return 7;
      }
      case "DUST": {
        return 8;
      }
      case "FOG": {
        return 9;
      }
      case "SAND": {
        return 10;
      }
      case "ASH": {
        return 11;
      }
      case "SQUALL": {
        return 12;
      }
      case "TORNADO": {
        return 13;
      }
      case "CLEAR": {
        return 14;
      }
      case "CLOUDS": {
        return 15;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const WeatherFilterJSON = {
  /**
   * Serializes WeatherFilter to JSON.
   */
  encode: function (msg: PartialDeep<WeatherFilter>): string {
    return JSON.stringify(WeatherFilterJSON._writeMessage(msg));
  },

  /**
   * Deserializes WeatherFilter from JSON.
   */
  decode: function (json: string): WeatherFilter {
    return WeatherFilterJSON._readMessage(
      WeatherFilterJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes WeatherFilter with all fields set to their default value.
   */
  initialize: function (msg?: Partial<WeatherFilter>): WeatherFilter {
    return {
      location: "",
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<WeatherFilter>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.location) {
      json["location"] = msg.location;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: WeatherFilter, json: any): WeatherFilter {
    const _location_ = json["location"];
    if (_location_) {
      msg.location = _location_;
    }
    return msg;
  },
};

export const WeatherRequestJSON = {
  /**
   * Serializes WeatherRequest to JSON.
   */
  encode: function (msg: PartialDeep<WeatherRequest>): string {
    return JSON.stringify(WeatherRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes WeatherRequest from JSON.
   */
  decode: function (json: string): WeatherRequest {
    return WeatherRequestJSON._readMessage(
      WeatherRequestJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes WeatherRequest with all fields set to their default value.
   */
  initialize: function (msg?: Partial<WeatherRequest>): WeatherRequest {
    return {
      weatherFilter: undefined,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<WeatherRequest>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.weatherFilter != undefined) {
      const _weatherFilter_ = WeatherFilterJSON._writeMessage(
        msg.weatherFilter,
      );
      json["weatherFilter"] = _weatherFilter_;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: WeatherRequest, json: any): WeatherRequest {
    const _weatherFilter_ = json["weatherFilter"];
    if (_weatherFilter_) {
      msg.weatherFilter = WeatherFilterJSON.initialize();
      WeatherFilterJSON._readMessage(msg.weatherFilter, _weatherFilter_);
    }
    return msg;
  },
};

export const WeatherCurrentJSON = {
  /**
   * Serializes WeatherCurrent to JSON.
   */
  encode: function (msg: PartialDeep<WeatherCurrent>): string {
    return JSON.stringify(WeatherCurrentJSON._writeMessage(msg));
  },

  /**
   * Deserializes WeatherCurrent from JSON.
   */
  decode: function (json: string): WeatherCurrent {
    return WeatherCurrentJSON._readMessage(
      WeatherCurrentJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes WeatherCurrent with all fields set to their default value.
   */
  initialize: function (msg?: Partial<WeatherCurrent>): WeatherCurrent {
    return {
      temperature: 0,
      windSpeed: 0,
      timestamp: 0n,
      humidity: 0,
      weather: WeatherType._fromInt(0),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<WeatherCurrent>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.temperature) {
      json["temperature"] = msg.temperature;
    }
    if (msg.windSpeed) {
      json["windSpeed"] = msg.windSpeed;
    }
    if (msg.timestamp) {
      json["timestamp"] = String(msg.timestamp);
    }
    if (msg.humidity) {
      json["humidity"] = msg.humidity;
    }
    if (msg.weather && WeatherTypeJSON._toInt(msg.weather)) {
      json["weather"] = msg.weather;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: WeatherCurrent, json: any): WeatherCurrent {
    const _temperature_ = json["temperature"];
    if (_temperature_) {
      msg.temperature = protoscript.parseDouble(_temperature_);
    }
    const _windSpeed_ = json["windSpeed"];
    if (_windSpeed_) {
      msg.windSpeed = protoscript.parseDouble(_windSpeed_);
    }
    const _timestamp_ = json["timestamp"];
    if (_timestamp_) {
      msg.timestamp = BigInt(_timestamp_);
    }
    const _humidity_ = json["humidity"];
    if (_humidity_) {
      msg.humidity = protoscript.parseNumber(_humidity_);
    }
    const _weather_ = json["weather"];
    if (_weather_) {
      msg.weather = WeatherType._fromInt(_weather_);
    }
    return msg;
  },
};

export const TemperatureRangeJSON = {
  /**
   * Serializes TemperatureRange to JSON.
   */
  encode: function (msg: PartialDeep<TemperatureRange>): string {
    return JSON.stringify(TemperatureRangeJSON._writeMessage(msg));
  },

  /**
   * Deserializes TemperatureRange from JSON.
   */
  decode: function (json: string): TemperatureRange {
    return TemperatureRangeJSON._readMessage(
      TemperatureRangeJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes TemperatureRange with all fields set to their default value.
   */
  initialize: function (msg?: Partial<TemperatureRange>): TemperatureRange {
    return {
      max: 0,
      min: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<TemperatureRange>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.max) {
      json["max"] = msg.max;
    }
    if (msg.min) {
      json["min"] = msg.min;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: TemperatureRange, json: any): TemperatureRange {
    const _max_ = json["max"];
    if (_max_) {
      msg.max = protoscript.parseDouble(_max_);
    }
    const _min_ = json["min"];
    if (_min_) {
      msg.min = protoscript.parseDouble(_min_);
    }
    return msg;
  },
};

export const WeatherDailyPointJSON = {
  /**
   * Serializes WeatherDailyPoint to JSON.
   */
  encode: function (msg: PartialDeep<WeatherDailyPoint>): string {
    return JSON.stringify(WeatherDailyPointJSON._writeMessage(msg));
  },

  /**
   * Deserializes WeatherDailyPoint from JSON.
   */
  decode: function (json: string): WeatherDailyPoint {
    return WeatherDailyPointJSON._readMessage(
      WeatherDailyPointJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes WeatherDailyPoint with all fields set to their default value.
   */
  initialize: function (msg?: Partial<WeatherDailyPoint>): WeatherDailyPoint {
    return {
      timestamp: 0n,
      temperature: 0,
      humidity: 0,
      temperatureRange: TemperatureRangeJSON.initialize(),
      weather: WeatherType._fromInt(0),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<WeatherDailyPoint>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.timestamp) {
      json["timestamp"] = String(msg.timestamp);
    }
    if (msg.temperature) {
      json["temperature"] = msg.temperature;
    }
    if (msg.humidity) {
      json["humidity"] = msg.humidity;
    }
    if (msg.temperatureRange) {
      const _temperatureRange_ = TemperatureRangeJSON._writeMessage(
        msg.temperatureRange,
      );
      if (Object.keys(_temperatureRange_).length > 0) {
        json["temperatureRange"] = _temperatureRange_;
      }
    }
    if (msg.weather && WeatherTypeJSON._toInt(msg.weather)) {
      json["weather"] = msg.weather;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: WeatherDailyPoint,
    json: any,
  ): WeatherDailyPoint {
    const _timestamp_ = json["timestamp"];
    if (_timestamp_) {
      msg.timestamp = BigInt(_timestamp_);
    }
    const _temperature_ = json["temperature"];
    if (_temperature_) {
      msg.temperature = protoscript.parseDouble(_temperature_);
    }
    const _humidity_ = json["humidity"];
    if (_humidity_) {
      msg.humidity = protoscript.parseNumber(_humidity_);
    }
    const _temperatureRange_ = json["temperatureRange"];
    if (_temperatureRange_) {
      TemperatureRangeJSON._readMessage(
        msg.temperatureRange,
        _temperatureRange_,
      );
    }
    const _weather_ = json["weather"];
    if (_weather_) {
      msg.weather = WeatherType._fromInt(_weather_);
    }
    return msg;
  },
};

export const WeatherReplyJSON = {
  /**
   * Serializes WeatherReply to JSON.
   */
  encode: function (msg: PartialDeep<WeatherReply>): string {
    return JSON.stringify(WeatherReplyJSON._writeMessage(msg));
  },

  /**
   * Deserializes WeatherReply from JSON.
   */
  decode: function (json: string): WeatherReply {
    return WeatherReplyJSON._readMessage(
      WeatherReplyJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes WeatherReply with all fields set to their default value.
   */
  initialize: function (msg?: Partial<WeatherReply>): WeatherReply {
    return {
      weatherPoint: [],
      weatherCurrent: WeatherCurrentJSON.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<WeatherReply>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.weatherPoint?.length) {
      json["weatherPoint"] = msg.weatherPoint.map(
        WeatherDailyPointJSON._writeMessage,
      );
    }
    if (msg.weatherCurrent) {
      const _weatherCurrent_ = WeatherCurrentJSON._writeMessage(
        msg.weatherCurrent,
      );
      if (Object.keys(_weatherCurrent_).length > 0) {
        json["weatherCurrent"] = _weatherCurrent_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: WeatherReply, json: any): WeatherReply {
    const _weatherPoint_ = json["weatherPoint"];
    if (_weatherPoint_) {
      for (const item of _weatherPoint_) {
        const m = WeatherDailyPointJSON.initialize();
        WeatherDailyPointJSON._readMessage(m, item);
        msg.weatherPoint.push(m);
      }
    }
    const _weatherCurrent_ = json["weatherCurrent"];
    if (_weatherCurrent_) {
      WeatherCurrentJSON._readMessage(msg.weatherCurrent, _weatherCurrent_);
    }
    return msg;
  },
};
